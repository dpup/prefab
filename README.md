
## Opinions

- UUIDs for unique identifiers generated by prefab.
- JWT for authorization tokens and cookies.
- Functional options pattern for configuring services and plugins, with
  configuration fallback.

## Key dependencies

- GRPC and GRPC Gateway ... obviously.
- Viper for configuration.
- Zap was chosen as default logging library.
- Gomail for sending emails, defaults to SMTP but can be customized.
- [TK] for templating. (e.g. for default login page)

## Features

- [CSRF Protection](#csrf-protection)
- [Plugin Model](#plugin-model)

### CSRF Protection

CSRF Protection is handled by middleware and is controlled by an option on the
method descriptor.

Possible values are "on", "off", and "auto", where "auto is
the default.

- "on" means CSRF protection is always needed.
- "off" means it is never needed.
- "auto" indicates CSRF protection is needed unless the HTTP method is `GET`, 
`HEAD`, or `OPTIONS`.

```proto
rpc Get(Request) returns (Response) {
  option (csrf_mode) = "on";
  option (google.api.http) = {
    get: "/get"
  };
}
```

CSRF Protection comes in two forms, an `X-CSRF-Protection` header, which can be
set on XHR requests, or a [signed double-submit cookie](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#signed-double-submit-cookie-recommended),
which are to be used for form posts and full-page navigations.

For the double-submit method, the CSRF Token can be requested from the
`/api/meta/config` endpoint. It is valid for 6 hours, querying the config
endpoint will extend the expiration. The token should be passed to the server in
a `csrf-token` query param.

The token can also be found in the `pf-ct` cookie. If you are using the cookie
instead of requesting the token from the config endpoint then your server code
will need to call `server.SendCSRFToken(ctx, signingKey)` at somepoint in the
user journey to ensure the cookie is set.

Example XHR:

```js
fetch('/api/users/154', {
  method: 'PATCH',
  headers: {
    'Content-Type': 'application/json',
    'X-CSRF-Protection': 1,
  },
  credentials: 'include',
  body: JSON.stringify({
    name: 'Frodo Baggins',
  })
})
```

### Plugin Model

Plugins are essentially server scoped singletons.

Plugins expose a `Name()` method which returns a string used for querying
plugins and for dependency resolution.

Plugins may expose a `Deps()` method which returns a list of names of plugins
that should be initialized before hand.

Plugins may expose a `ServerOptions()` method, which allows for the registration
of HTTP handlers, GRPC handlers, and interceptors.

Plugins may expose an `Init()` method, which is called when the server starts
up, this can be used for getting references to other plugins.

By convention, plugins should be created by a `Plugin` function. If the plugin
is intended to be used by other plugins, it's name should be exported as
`PluginName`. For example, `gpt.Plugin(...)` and `gpt.PluginName`.
